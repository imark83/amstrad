; NEWTON FRACTAL ON CPC 464
; 

; INK COLOURS
;  0 BLACK
;  D WHITE
;  1 BLUE
;  2 BRIGHT BLUE
;  3 RED
;  6 BRIGHT RED
;  9 GREEN
; 13 BRIGHT GREEN

; MODULES
; - INIT-END SCREEN MODE
; - LOOK UP TABLE
; - PIXEL (X,Y) TO BYTE + XOR MASK 
; - COMPLEX ARITMETIC
; - ITERATION

; FIRMWARE LIBRARY
; #BBFF -> SCR INITIALISE (AF BC DE HL CORRUPT)
; #BC14 -> SCR CLEAR (AF BC DE HL CORRUPT)
; #BC26 -> SCR NEXT LINE: HL=HL+1LINE (AF CORRUPT)
; #BC11 -> SCR GET MODE: A=OLD MODE
; #BC0E -> SCR SET MODE: MODE=A (AF BC DE HL CORRUPT)
; #BC38 -> SCR SET BORDER: BORDER=BC (AF,BC,DE,HL CORRUPT)
; #BC3B -> SCR GET BORDER: BC=BORDER (AF,DE,HL CORRUPT)
; #BC35 -> SCR GET INK: BC=INK(A) (AF,DE,HL CORRUPT)
; #BC32 -> SCR SET INK; INK(A) = BC
;
; #BB18 -> WAIT KEY
;
; #BD3D -> MOVE; (HL)=(DE) (AF CORRUPT)
; #BD58 -> REAL ADDITION; (HL)+=(DE) (AF BC DE IX IY CORRUPT)
; #BD5B -> REAL SUBTRACTION; (HL)-=(DE) (AF BC DE IX IY CORRUPT)
; #BD6D -> REAL NEGATION; (HL) =-(HL) (AF BC DE IX IY CORRUPT)
; #BD61 -> REAL MULTIPLICATION; (HL)*=(DE) (AF BC DE IX IY CORRUPT)


SCRINIT:
OLDMODE: DEFS 1     ; BACK UP
; INITS SCREEN 
; AF,BC CORRUPT

CALL #BC11
LD HL,OLDMODE
LD (HL),A           ; BACK UP MODE
LD A,1
CALL #BC0E          ; SET MODE 1
LD BC,#0
CALL #BC38          ; SET BORDER BLACK
LD A,0
LD BC,#0
CALL #BC32          ; SET INK(0)=BLACK
LD A,1
LD BC,#0202
CALL #BC32          ; SET INK(1)=BRIGHT BLUE
LD A,2
LD BC,#1313
CALL #BC32          ; SET INK(2)=BRIGHT GREEN
LD A,3
LD BC,#0606
CALL #BC32          ; SET INK(3)=BRIGHT RED
RET

SCRRST:             
; RESTORE SCREEN
LD HL,OLDMODE
LD A,(HL)
CALL #BC0E          ; RESTORE MODE

LD A,0
LD BC,#0
CALL #BC32          ; SET INK(0)=BLACK
LD A,1
LD BC,#0D0D
CALL #BC32          ; SET INK(1)=WHITE

RET 





MKTAB:
; MAKE LOOK UP TABLE
; STORAGE
SCRTAB: DEFS 2*200
LD B,200            ; NUMBER OF LINES
LD IX,SCRTAB        ; START OF THE TABLE
LD HL,#C000
LMT:                ; LOOP
  LD (IX+0),L       ; WRITE TO THE TABLE
  LD (IX+1),H

  INC IX            ; NEXT 2 BYTES OF TABLE
  INC IX
  CALL #BC26        ; CALL NEXT LINE
  DJNZ MLT1
RET



; COMPLEX ARITHMETIC
; COMPLEX STORED AS 10 BYTES IN MEMORY
; HL POINTS TO THE FIRST BYTE, REAL PART
; AF BC DE IX IY CORRUPT

; FLOAT AUX VARIABLES
FAUX1: DEFS 5
FAUX2: DEFS 5

CADD:
; (HL) = (HL) + (DE)
PUSH DE             ; STORE DE
CALL #BD58          ; ADD REAL PART
POP DE
LD B,H
LD C,L              ; BACK UP HL IN BC
LD HL,5
ADD HL,DE            
LD D,H
LD E,L              ; DE+=5
LD HL,5
ADD HL,BC           ; HL+=5
CALL #BD58          ; ADD IMAG PART
RET



CSUB:
; (HL) = (HL) - (DE)
PUSH DE             ; STORE DE
CALL #BD5B          ; SUB REAL PART
POP DE
LD B,H
LD C,L              ; BACK UP HL IN BC
LD HL,5
ADD HL,DE            
LD D,H
LD E,L              ; DE+=5
LD HL,5
ADD HL,BC           ; HL+=5
CALL #BD5B          ; SUB IMAG PART
RET




CNEG:
; (HL) = -(HL)
CALL #BD5B          ; NEG REAL PART
LD B,H
LD C,L              ; BACK UP HL IN BC
LD HL,5
ADD HL,BC           ; HL+=5
CALL #BD6D          ; NEG IMAG PART
RET




CMUL:
; REAL MULTIPLICATION (&BD61 for the 464)
; (HL) = (HL) * (DE)
;
; AUX1=(HL)
; AUX2=(HL+5)
; (HL) = (HL)*(DE)
; (HL+5) = (HL+5)*(DE+5)
; (HL) = (HL) - (HL+5)
; (HL+5) = AUX2
; (HL+5) = (HL+5)*(DE)
; AUX1 = AUX1*(DE+5)
; (HL+5) = (HL+5) + AUX1

PUSH DE
PUSH HL
; AUX1=(HL)
LD D,H
LD E,L
LD HL,FAUX1
CALL FMOVE

; AUX2=(HL+5)
POP DE
PUSH DE
LD HL,5
ADD HL,DE
LD D,H
LD E,L
LD HL,FAUX2
CALL FMOVE

; (HL) = (HL)*(DE)
POP HL
POP DE
PUSH DE
PUSH HL
CALL FMUL

; (HL+5) = (HL+5)*(DE+5)
POP BC
POP DE
PUSH DE
PUSH BC
LD HL,5
ADD HL,DE
LD D,H
LD E,L
LD HL,5
ADD HL,BC
CALL FMUL

; (HL) = (HL) - (HL+5)
POP BC
PUSH BC
LD HL,5
ADD HL,BC
LD D,H
LD E,L
LD H,B
LD L,C
CALL FSUB

; (HL+5) = AUX2
POP DE
PUSH DE
LD HL,5
ADD HL,DE
LD DE,FAUX2
CALL FMOVE

; (HL+5) = (HL+5)*(DE)
POP BC
POP DE
PUSH DE
PUSH BC
LD HL,5
ADD HL,BC
CALL FMUL

; AUX1 = AUX1*(DE+5)
POP BC
POP DE
PUSH DE
PUSH BC
LD HL,5
ADD HL,DE
LD D,H
LD E,L
LD HL,FAUX1
CALL FMUL

; (HL+5) = (HL+5) + AUX1
POP BC
PUSH BC
LD HL,5
ADD HL,BC
LD DE,FAUX1
CALL FADD

POP HL
POP DE
RET

